{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n Elementos Programables II","text":""},{"location":"#portafolio-de-actividades","title":"Portafolio de Actividades","text":"<p>Introducci\u00f3n a la mec\u00e1tronica Departamento de Ciencias e Ingenier\u00edas | Universidad Iberoamericana Puebla, M\u00e9xico.</p> <p></p> <p>Karen Itzel Najera De Gante</p> <p>Ingenier\u00eda me\u00e1tronica | karen.najera@iberopuebla.mx</p> <p>Resumen: Soy estudiante de d\u00e9cimo semestre de Ingenier\u00eda Mecatr\u00f3nica, con formaci\u00f3n previa en Ingenier\u00eda Mec\u00e1nica. Mi pasi\u00f3n por los desaf\u00edos y la innovaci\u00f3n me llev\u00f3 a continuar mis estudios en una segunda carrera, con el objetivo de ampliar mis conocimientos y abrir mayores oportunidades en el campo laboral. Durante seis meses trabaj\u00e9 como analista en EDAG Test Lab M\u00e9xico, donde adquir\u00ed experiencia en pruebas y validaciones dentro del sector automotriz. Actualmente, sigo desarrollando mis habilidades en \u00e1reas multidisciplinarias, combinando mec\u00e1nica, electr\u00f3nica y automatizaci\u00f3n para enfrentar retos tecnol\u00f3gicos con una visi\u00f3n integral.</p> <p></p>"},{"location":"PRACTICA%2010/","title":"Pr\u00e1ctica 10: Filtrado y Limpieza de Imagen para Detecci\u00f3n de Monedas mediante Operaciones Morfol\u00f3gicas","text":""},{"location":"PRACTICA%2010/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera </li> <li>Curso / Asignatura: Elementos Programables / Proyecto de Control </li> <li>Fecha: 05/12/2025 </li> <li>Descripci\u00f3n breve: Esta pr\u00e1ctica implementa un proceso de filtrado digital para identificar monedas dentro de una imagen est\u00e1tica mediante el uso de OpenCV. Se utilizan t\u00e9cnicas como manipulaci\u00f3n de canales RGB, umbralizaci\u00f3n, enmascaramiento, selecci\u00f3n de rangos en HSV y operaciones morfol\u00f3gicas tipo opening (erosi\u00f3n + dilataci\u00f3n). Finalmente, el sistema detecta contornos, marca las monedas encontradas y etiqueta cada una. El objetivo es comprender c\u00f3mo la secuencia correcta de transformaciones permite limpiar ruido y aislar objetos de inter\u00e9s.</li> </ul>"},{"location":"PRACTICA%2010/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Aplicar t\u00e9cnicas fundamentales de procesamiento digital de im\u00e1genes para segmentar monedas dentro de una escena, eliminando ruido y resaltando contornos mediante operadores morfol\u00f3gicos.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Manipular canales de color para resaltar regiones de inter\u00e9s. </li> <li>Implementar umbralizaci\u00f3n y creaci\u00f3n de m\u00e1scaras binarias. </li> <li>Utilizar operaciones morfol\u00f3gicas (erosi\u00f3n, dilataci\u00f3n y opening) para limpiar la imagen. </li> <li>Detectar contornos y calcular centroides usando momentos.</li> </ul>"},{"location":"PRACTICA%2010/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Lectura y preprocesamiento de im\u00e1genes con OpenCV. </li> <li>Aplicaci\u00f3n de umbralizaci\u00f3n y conversi\u00f3n de espacios de color. </li> <li>Obtenci\u00f3n de contornos y centroides de cada moneda. </li> <li> <p>Uso de kernels el\u00edpticos para filtrado morfol\u00f3gico.</p> </li> <li> <p>Exclusiones / restricciones: </p> </li> <li>No se realizan t\u00e9cnicas avanzadas como segmentaci\u00f3n adaptativa, watershed o clustering. </li> <li>El an\u00e1lisis se limita a una imagen est\u00e1tica; no se incluye video ni seguimiento temporal. </li> <li>No se aplica clasificaci\u00f3n basada en tama\u00f1o o tipo de moneda; solo se detectan.</li> </ul>"},{"location":"PRACTICA%2010/#4-desarrollo","title":"4) Desarrollo","text":"<p>_En esta pr\u00e1ctica se utiliz\u00f3 una imagen con varias monedas sobre un fondo uniforme. El procesamiento inici\u00f3 con la lectura de la imagen original y su reducci\u00f3n de tama\u00f1o para facilitar el an\u00e1lisis. Posteriormente, se manipularon los canales RGB eliminando selectivamente los canales rojo y azul para conservar \u00fanicamente la informaci\u00f3n del canal verde, el cual proporcionaba el mejor contraste entre las monedas y el fondo.</p> <p>Una vez aislado el canal de inter\u00e9s, se aplic\u00f3 una umbralizaci\u00f3n binaria, que permiti\u00f3 crear una m\u00e1scara preliminar de regiones brillantes. Para refinar la segmentaci\u00f3n, la m\u00e1scara fue convertida al espacio HSV, donde se aplic\u00f3 un nuevo filtrado mediante selecci\u00f3n de rangos, lo cual mejor\u00f3 la separaci\u00f3n entre monedas y ruido.</p> <p>El n\u00facleo de la pr\u00e1ctica se centr\u00f3 en las operaciones morfol\u00f3gicas, particularmente el opening, que combina erosi\u00f3n seguida de dilataci\u00f3n. Estas operaciones son esenciales para eliminar peque\u00f1os puntos de ruido y regularizar bordes sin afectar en gran medida el tama\u00f1o real de los objetos. Se utiliz\u00f3 un kernel el\u00edptico, adecuado para preservar la geometr\u00eda circular de las monedas.</p> <p>Tras limpiar la imagen, se realiz\u00f3 la detecci\u00f3n de contornos mediante findContours. Para cada contorno se calcularon sus momentos, necesarios para determinar el centroide, el cual se marc\u00f3 en la imagen mediante un punto verde. Finalmente, cada moneda se etiquet\u00f3 con un n\u00famero consecutivo, empleando texto superpuesto, lo que permiti\u00f3 identificar de manera clara cu\u00e1ntas monedas fueron detectadas y su posici\u00f3n._</p>"},{"location":"PRACTICA%2010/#5-resultados","title":"5) Resultados","text":"<p>_El sistema logr\u00f3 segmentar correctamente las monedas presentes en la imagen, eliminando la mayor parte del ruido y resaltando \u00fanicamente los objetos deseados. Gracias al uso del canal verde y a la selecci\u00f3n adecuada del umbral, la m\u00e1scara inicial fue suficientemente precisa para que las operaciones morfol\u00f3gicas terminaran de limpiar la escena.</p> <p>La detecci\u00f3n de contornos identific\u00f3 cada moneda de manera clara y estable. Los centroides calculados mediante los momentos geom\u00e9tricos fueron precisos y permitieron etiquetar correctamente cada objeto. El resultado final muestra la imagen original con contornos marcados en color azul y con un n\u00famero asociado a cada moneda, confirmando la efectividad del m\u00e9todo implementado._</p> <p>Video control mano Video control PD</p>"},{"location":"PRACTICA%2010/#6-archivos-adjuntos-codigo","title":"6) Archivos Adjuntos / C\u00f3digo","text":"<p>En este apartado se integrar\u00e1n los archivos correspondientes al firmware del ESP32. Se incluir\u00e1 un archivo destinado al control aut\u00f3nomo mediante detecci\u00f3n de la pelota y otro para el modo controlado por la mano del usuario. Tambi\u00e9n se agregar\u00e1n las im\u00e1genes y diagramas asociados al montaje f\u00edsico de la plataforma y a las pruebas realizadas.</p> <pre><code>import cv2\nimport numpy as np\n'''OPENING'''\n# Cargar imagen\nimage = cv2.imread('E2_week2-main/images\\monedas.jpg')\nimage = cv2.resize(image, (0,0), fx=0.5, fy=0.5)\nimage1 = image.copy()\nimage1 [:, :, 2] = 0\nimage1 [:, :, 0] = 0\n\n\n\ngreen_channel = image[:, :, 1]\nth, imThresh = cv2.threshold(image1, 70, 255, cv2.THRESH_BINARY)\nmascara = cv2.cvtColor(imThresh, cv2.COLOR_BGR2HSV)\nmask1=cv2.inRange(mascara,(50,100,100),(80,255,255))\n\n\n\n# Crear kernel\nkSize = 3\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2*kSize+1, 2*kSize+1), (kSize, kSize))\n'''OPEN Metodo 1'''\n# Perform Erosion\n\n# Perform Dilation\nimOpen = cv2.dilate(mask1, kernel, iterations=1)\nimEroded = cv2.erode(imOpen, kernel, iterations=3)\nimEroded  = cv2.dilate(imEroded, kernel, iterations=1)\n\n'''OPEN Metodo 2'''\n#imageMorphOpened = cv2.morphologyEx(mask1, cv2.MORPH_OPEN,\n                        #kernel,iterations=3)\n# Mostrar Imagenes\ncontours, hierarchy = cv2.findContours(imEroded, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncv2.drawContours(image, contours, -1, (255, 0, 0), 3)\nfor index,cnt in enumerate(contours):\n    M = cv2.moments(cnt)\n    x = int(round(M[\"m10\"]/M[\"m00\"]))\n    y = int(round(M[\"m01\"]/M[\"m00\"]))\n    cv2.circle(image, (x,y), 10, (0,255,0), -1)\n    # Marcar Texto\n    cv2.putText(image, \"{}\".format(index + 1), (x-10, y+10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)\ncv2.imshow(\"OG\", image)\n\ncv2.imshow(\"Eroded\", imEroded)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"PRACTICA%2010/#7-conclusion","title":"7) Conclusi\u00f3n}","text":"<p>_La pr\u00e1ctica permiti\u00f3 comprender de manera integral c\u00f3mo el preprocesamiento adecuado de una imagen influye directamente en la calidad de la segmentaci\u00f3n y en la detecci\u00f3n de objetos de inter\u00e9s. A trav\u00e9s de la manipulaci\u00f3n de canales de color, la aplicaci\u00f3n de umbralizaci\u00f3n y el uso de operaciones morfol\u00f3gicas, fue posible limpiar eficazmente la imagen y aislar las monedas presentes en la escena. El uso de un kernel el\u00edptico result\u00f3 especialmente adecuado debido a la geometr\u00eda circular de los objetos, permitiendo conservar su forma mientras se eliminaba ruido no deseado.</p> <p>Asimismo, la obtenci\u00f3n de contornos y el c\u00e1lculo de centroides evidenciaron la importancia de las etapas finales del procesamiento, pues permiten no solo identificar los objetos, sino tambi\u00e9n describir su posici\u00f3n y caracter\u00edsticas b\u00e1sicas dentro de la imagen. En conjunto, esta pr\u00e1ctica demuestra c\u00f3mo la combinaci\u00f3n secuencial de filtros y transformaciones puede resolver problemas de segmentaci\u00f3n de manera robusta y eficiente, preparando el camino para aplicaciones m\u00e1s avanzadas de visi\u00f3n computacional._</p>"},{"location":"PROYECTO%20FINAL/","title":"Proyecto: Plataforma de Balanceo Activo para Mantener una Pelota Centrada","text":""},{"location":"PROYECTO%20FINAL/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera </li> <li>Curso / Asignatura: Elementos Programables / Proyecto de Control </li> <li>Fecha: 05/12/2025 </li> <li>Descripci\u00f3n breve: Este proyecto implementa una plataforma inclinable controlada por 3 servomotores (2 para eje X: izquierdo/derecho y 1 para eje Y: arriba/abajo) cuyo objetivo es mantener una pelota ligera en el centro. Se desarrollaron dos m\u00e9todos de visi\u00f3n, uno basado en detecci\u00f3n por color para ubicar una pelota y otro basado en detecci\u00f3n de l\u00edneas para controlar la plataforma con la mano. Adem\u00e1s, se integr\u00f3 un controlador PD que recibe la posici\u00f3n detectada por la c\u00e1mara y env\u00eda comandos al ESP32 mediante Bluetooth. El ESP32 ejecuta el movimiento con rampado, l\u00edmites y retorno autom\u00e1tico a posici\u00f3n neutral.</li> </ul>"},{"location":"PROYECTO%20FINAL/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Implementar y validar un sistema embebido que, combinando visi\u00f3n por computadora y control PD, mantenga una pelota centrada sobre una plataforma inclinable y tambi\u00e9n permita un segundo modo de control mediante gestos de la mano.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Dise\u00f1ar la plataforma y la distribuci\u00f3n de servos (2 en X, 1 en Y). </li> <li>Implementar el nodo de visi\u00f3n que detecte la pelota y calcule acciones PD. </li> <li>Implementar firmware en ESP32 que reciba comandos por Bluetooth y mueva los servos de forma segura (rampa y l\u00edmites). </li> <li>Probar y ajustar ganancias PD para lograr compromiso entre rapidez y suavidad.</li> </ul>"},{"location":"PROYECTO%20FINAL/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Detecci\u00f3n de pelota por color con OpenCV (Python). </li> <li>C\u00e1lculo de control PD en el nodo de visi\u00f3n (Python). </li> <li>Comunicaci\u00f3n Bluetooth entre PC (visi\u00f3n) y ESP32. </li> <li> <p>Firmware ESP32 que aplica comandos a 3 servos con l\u00edmite, rampa y timeout de seguridad.</p> </li> <li> <p>Exclusiones / restricciones: </p> </li> <li>No se implementa realimentaci\u00f3n de posici\u00f3n (no hay encoders). </li> <li>No se implementa autenticaci\u00f3n/TLS en la comunicaci\u00f3n. </li> <li>El sistema asume condiciones de iluminaci\u00f3n y contraste adecuadas para la detecci\u00f3n por color.</li> </ul>"},{"location":"PROYECTO%20FINAL/#4-resultados","title":"4) Resultados","text":"<p>Al ejecutar el sistema: la c\u00e1mara detecta la pelota y el nodo de visi\u00f3n calcula el error en pixeles respecto al centro de la imagen (X, Y). El controlador PD calcula correcciones y env\u00eda comandos <code>DX</code> y <code>DY</code> por Bluetooth al ESP32 (o bien puede enviar directamente \u00e1ngulos <code>AX,AY,AZ</code>). El ESP32 aplica esos comandos a los servos con rampado, l\u00edmites de \u00e1ngulo y timeout de seguridad; si no recibe comandos vuelve a la posici\u00f3n neutral.</p> <p>Los par\u00e1metros PD (<code>Kp</code>, <code>Kd</code>), el suavizado EMA, <code>MAX_STEP</code> y <code>MAX_ACCEL</code> permiten ajustar el compromiso entre rapidez y suavidad. Para pelotas muy ligeras las ganancias altas producen movimientos bruscos que lanzan la pelota; por eso recomendamos limitar el paso y usar rampa.</p> <p>Durante las pruebas del sistema, la c\u00e1mara logr\u00f3 detectar de manera efectiva la posici\u00f3n de la pelota en la imagen y generar un error en los ejes X y Y compar\u00e1ndolo con el centro te\u00f3rico. El nodo de visi\u00f3n calcul\u00f3 las acciones de control PD y las envi\u00f3 al ESP32 como comandos de correcci\u00f3n o como \u00e1ngulos finales, dependiendo del modo de operaci\u00f3n. El ESP32 ejecut\u00f3 estos movimientos de forma estable gracias al rampado, que evit\u00f3 cambios de posici\u00f3n bruscos y mantuvo el movimiento continuo sin sacudidas. La plataforma pudo responder correctamente a los desplazamientos de la pelota, inclin\u00e1ndose de manera proporcional y derivativa para regresar la pelota al centro. El segundo modo de control, basado en la mano del usuario, tambi\u00e9n mostr\u00f3 un funcionamiento adecuado y permiti\u00f3 mover la plataforma con libertad mientras se visualizaban las l\u00edneas gu\u00eda en pantalla. Durante las pruebas se comprob\u00f3 que los ajustes de Kp y Kd afectan significativamente el comportamiento: valores altos causan oscilaciones intensas y movimientos excesivamente r\u00e1pidos, mientras que valores moderados permiten un equilibrio entre estabilidad y capacidad de reacci\u00f3n. El sistema demostr\u00f3 ser funcional bajo ambos modos de visi\u00f3n, cumpliendo con los objetivos planteados.</p> <p>Video control mano Video control PD</p>"},{"location":"PROYECTO%20FINAL/#5-archivos-adjuntos-codigo","title":"5) Archivos Adjuntos / C\u00f3digo","text":"<p>En este apartado se integrar\u00e1n los archivos correspondientes al firmware del ESP32 y a los dos scripts de visi\u00f3n. Se incluir\u00e1 un archivo destinado al control aut\u00f3nomo mediante detecci\u00f3n de la pelota y otro para el modo controlado por la mano del usuario. Tambi\u00e9n se agregar\u00e1n las im\u00e1genes y diagramas asociados al montaje f\u00edsico de la plataforma y a las pruebas realizadas.</p> <ul> <li>Control por mano <pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// === Buffer para lectura BT no bloqueante ===\nString btBuffer;\n\n// === Pines de los servos ===\n#define SERVO_IZQ   25\n#define SERVO_DER   15\n#define SERVO_VERT  33\n\n// === PWM ===\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n\n// Convierte de \u00e1ngulo l\u00f3gico (0..180, centro 90) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico \u2192 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n\n// === Rango y rampa ===\nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n\n// Estado en grados L\u00d3GICOS\nint posIzq = 90;\nint posDer = 90;\nint posVert= 60;\n\nint tgtIzq = 90;\nint tgtDer = 90;\nint tgtVert= 60;\n\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n\n  posIzq = go(posIzq, tgtIzq);\n  posDer = go(posDer, tgtDer);\n  posVert= go(posVert,tgtVert);\n\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_IZQ, posIzq);\n  writeServoLogical(SERVO_DER, posDer);\n  writeServoLogical(SERVO_VERT,posVert);\n}\n\n// Parsea \"ANG:izq,der,vert\"\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aDer, int &amp;aVert){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  int c2 = data.indexOf(',', c1 + 1);\n  if (c2 &lt; 0) return false;\n\n  String sIzq  = data.substring(0, c1);\n  String sDer  = data.substring(c1 + 1, c2);\n  String sVert = data.substring(c2 + 1);\n\n  sIzq.trim();\n  sDer.trim();\n  sVert.trim();\n\n  aIzq  = sIzq.toInt();\n  aDer  = sDer.toInt();\n  aVert = sVert.toInt();\n\n  return true;\n}\n\n// ======== SETUP ========\nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-BallPlatform\");\n\n  configServo(SERVO_IZQ, posIzq);\n  configServo(SERVO_DER, posDer);\n  configServo(SERVO_VERT,posVert);\n\n  Serial.println(\"ESP32 listo\");\n  tLastCmd = millis();\n}\n\n// ======== LOOP ========\nvoid loop(){\n\n  // --- Lectura Bluetooth no bloqueante ---\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n\n        if (msg == \"LOST\") {\n          // PC perdi\u00f3 mano/objetivo \u2192 \"centro\"\n          tgtIzq  = 90;\n          tgtDer  = 90;\n          tgtVert = 60;\n          Serial.println(\"Comando LOST: centro.\");\n\n        } else if (msg == \"ZERO\") {\n          // \ud83d\udd39 TODOS los servos a 180 f\u00edsicos\n          //    \u21d2 0 l\u00f3gico por el mapeo invertido\n          tgtIzq  = 0;\n          tgtDer  = 0;\n          tgtVert = 0;\n          Serial.println(\"Comando ZERO: servos \u2192 180\u00b0 fisico\");\n\n        } else {\n          int aIzq, aDer, aVert;\n          if (parseAngulos(msg, aIzq, aDer, aVert)) {\n            tgtIzq  = constrain(aIzq,  LIM_MIN, LIM_MAX);\n            tgtDer  = constrain(aDer,  LIM_MIN, LIM_MAX);\n            tgtVert = constrain(aVert, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; IZQ:%d DER:%d VERT:%d\\n\", tgtIzq, tgtDer, tgtVert);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al centro\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtIzq = 90;\n    tgtDer = 90;\n    tgtVert= 60;\n  }\n\n  aplicarRampa();\n  delay(1);\n}\n</code></pre></li> </ul> <p><pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\nimport mediapipe as mp\n\n# ========= BLUETOOTH =========\ndevice_mac = \"F0:24:F9:0C:4C:DE\"   # &lt;-- MISMA MAC\nport = 1\n\n# ========= PAR\u00c1METROS MAPEO =========\n# Posiciones \"neutras\" de la plataforma en grados l\u00f3gicos (0-180)\nNEUT_IZQ  = 90\nNEUT_DER  = 90\nNEUT_VERT = 60\n\n# Cu\u00e1nto giro de mano consideramos \u00fatil (en grados)\nMAX_HAND_TILT_X = 30.0   # \u00b130\u00b0 de roll mano\nMAX_HAND_TILT_Y = 30.0   # \u00b130\u00b0 de pitch mano\n\n# Cu\u00e1nto puede moverse el servo alrededor de su neutro\nMAX_SERVO_OFFSET_X = 40.0  # servos izq/der \u00b140\u00b0\nMAX_SERVO_OFFSET_Y = 30.0  # servo vertical \u00b130\u00b0\n\n# Invertir ejes si hace falta\nINVERT_X = True\nINVERT_Y = True\n\n# L\u00edmite de frecuencia de env\u00edo\nMIN_DT_CMD = 0.015  # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\n\n# Referencias de \u00e1ngulo (se calibran con 'c')\nbase_angleX = None   # \u00e1ngulo neutro entre \u00edndice \u2194 anular\nbase_angleY = None   # \u00e1ngulo neutro entre mu\u00f1eca \u2194 dedo medio\n\n# ======== CONEXI\u00d3N BLUETOOTH ========\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\" Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# ======== MEDIAPIPE HANDS ========\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(max_num_hands=1,\n                       min_detection_confidence=0.5,\n                       min_tracking_confidence=0.5)\nmp_draw = mp.solutions.drawing_utils\n\n# ======== C\u00c1MARA ========\nvideo = cv2.VideoCapture(0)  # usa 0 o 1 seg\u00fan tu c\u00e1mara\n\ndef calc_angle(p1, p2):\n    \"\"\"Devuelve \u00e1ngulo (rad, deg) de la l\u00ednea p1-&gt;p2 respecto al eje X.\"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    theta = np.arctan2(dy, dx)          # radianes\n    theta_deg = np.degrees(theta)       # grados\n    return theta, theta_deg\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    frame = cv2.flip(frame, 1)\n    h, w = frame.shape[:2]\n\n    now = time.time()\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # Procesar mano\n    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    results = hands.process(img_rgb)\n\n    hay_mano = False\n    angleX_deg = None\n    angleY_deg = None\n\n    if results.multi_hand_landmarks:\n        hay_mano = True\n        hand_landmarks = results.multi_hand_landmarks[0]\n        mp_draw.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n\n        # ====== PUNTOS CLAVE ======\n        idx_tip  = hand_landmarks.landmark[8]   # \u00edndice\n        mid_tip  = hand_landmarks.landmark[12]  # medio\n        ring_tip = hand_landmarks.landmark[16]  # anular\n        wrist    = hand_landmarks.landmark[0]   # mu\u00f1eca\n\n        def to_px(lm):\n            return int(lm.x * w), int(lm.y * h)\n\n        idx_pt  = to_px(idx_tip)\n        mid_pt  = to_px(mid_tip)\n        ring_pt = to_px(ring_tip)\n        wrist_pt= to_px(wrist)\n\n        # Dibujar puntos (rojos)\n        for p in [idx_pt, mid_pt, ring_pt, wrist_pt]:\n            cv2.circle(frame, p, 8, (0, 0, 255), -1)\n\n        # ====== L\u00cdNEA VERDE: \u00edndice \u2194 anular (roll / X) ======\n        cv2.line(frame, idx_pt, ring_pt, (0, 255, 0), 3)\n        _, angleX_deg = calc_angle(idx_pt, ring_pt)\n\n        # ====== L\u00cdNEA MAGENTA: mu\u00f1eca \u2194 dedo medio (pitch / Y) ======\n        cv2.line(frame, wrist_pt, mid_pt, (255, 0, 255), 3)\n        _, angleY_deg = calc_angle(wrist_pt, mid_pt)\n\n        # Centro aproximado de la mano (turquesa)\n        cx = int((wrist_pt[0] + idx_pt[0] + ring_pt[0]) / 3)\n        cy = int((wrist_pt[1] + idx_pt[1] + ring_pt[1]) / 3)\n        cv2.circle(frame, (cx, cy), 8, (255, 255, 0), -1)\n\n        # Mostrar \u00e1ngulos\n        cv2.putText(frame, f\"AX:{angleX_deg:7.2f} deg\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n        cv2.putText(frame, f\"AY:{angleY_deg:7.2f} deg\", (10, 50),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n\n        # ====== SI YA HAY CALIBRACI\u00d3N, MAPEAR DIRECTO A \u00c1NGULOS DE SERVOS ======\n        if base_angleX is not None and base_angleY is not None:\n            # Diferencias de \u00e1ngulo respecto a la mano neutra\n            dAX = angleX_deg - base_angleX   # roll relativo\n            dAY = angleY_deg - base_angleY   # pitch relativo\n\n            # Normalizar al rango [-1, 1] seg\u00fan el m\u00e1ximo giro que consideras\n            dAX_norm = np.clip(dAX / MAX_HAND_TILT_X, -1.0, 1.0)\n            dAY_norm = np.clip(dAY / MAX_HAND_TILT_Y, -1.0, 1.0)\n\n            # Invertir si quieres que gire al rev\u00e9s\n            if INVERT_X:\n                dAX_norm = -dAX_norm\n            if INVERT_Y:\n                dAY_norm = -dAY_norm\n\n            # Offset en grados de servo\n            servo_off_X = dAX_norm * MAX_SERVO_OFFSET_X\n            servo_off_Y = dAY_norm * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos L\u00d3GICOS absolutos para cada servo\n            ang_izq  = NEUT_IZQ  - servo_off_X\n            ang_der  = NEUT_DER  + servo_off_X\n            ang_vert = NEUT_VERT - servo_off_Y\n\n            # Limitar 0..180\n            ang_izq  = int(np.clip(ang_izq,  0, 180))\n            ang_der  = int(np.clip(ang_der,  0, 180))\n            ang_vert = int(np.clip(ang_vert, 0, 180))\n\n            cv2.putText(frame, f\"IZQ:{ang_izq} DER:{ang_der} VERT:{ang_vert}\",\n                        (10, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0,255,255), 2)\n\n            # Enviar al ESP32\n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_izq},{ang_der},{ang_vert}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\" Error al enviar ANG:\", e)\n        else:\n            cv2.putText(frame, \"Presiona 'c' para calibrar mano neutra y mandar ZERO\",\n                        (10, h-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 0, 255), 2)\n\n    else:\n        cv2.putText(frame, \"NO HAND\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Sin mano -&gt; opcional: mandar LOST\n        if send_allowed:\n            try:\n                sock.send(b\"LOST\\n\")\n                last_cmd_time = now\n            except Exception as e:\n                print(\" Error al enviar LOST:\", e)\n\n    cv2.imshow(\"Hand Angle Direct Control\", frame)\n    key = cv2.waitKey(1) &amp; 0xFF\n\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Calibrar mano neutra si hay \u00e1ngulos v\u00e1lidos\n        if angleX_deg is not None and angleY_deg is not None:\n            base_angleX = angleX_deg\n            base_angleY = angleY_deg\n            print(f\"Calibrado! base_angleX={base_angleX:.2f}, base_angleY={base_angleY:.2f}\")\n        # Mandar comando ZERO para llevar servos a 180 f\u00edsicos\n        try:\n            sock.send(b\"ZERO\\n\")\n            last_cmd_time = time.time()\n            print(\"Comando ZERO enviado (servos a 180 fisico).\")\n        except Exception as e:\n            print(\" Error al enviar ZERO:\", e)\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre> - Control PD </p> <p><pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// === Buffer para lectura BT no bloqueante ===\nString btBuffer;\n\n// === Pines de los servos ===\n#define SERVO_IZQ   25\n#define SERVO_DER   15\n#define SERVO_VERT  33\n\n// === PWM ===\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n\n// Convierte de \u00e1ngulo l\u00f3gico (0..180, centro 90) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico \u2192 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n\n// === Rango y rampa ===\nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n\n// Estado en grados L\u00d3GICOS\nint posIzq = 90;\nint posDer = 90;\nint posVert= 60;\n\nint tgtIzq = 90;\nint tgtDer = 90;\nint tgtVert= 60;\n\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n\n  posIzq = go(posIzq, tgtIzq);\n  posDer = go(posDer, tgtDer);\n  posVert= go(posVert,tgtVert);\n\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_IZQ, posIzq);\n  writeServoLogical(SERVO_DER, posDer);\n  writeServoLogical(SERVO_VERT,posVert);\n}\n\n// Parsea \"ANG:izq,der,vert\"\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aDer, int &amp;aVert){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  int c2 = data.indexOf(',', c1 + 1);\n  if (c2 &lt; 0) return false;\n\n  String sIzq  = data.substring(0, c1);\n  String sDer  = data.substring(c1 + 1, c2);\n  String sVert = data.substring(c2 + 1);\n\n  sIzq.trim();\n  sDer.trim();\n  sVert.trim();\n\n  aIzq  = sIzq.toInt();\n  aDer  = sDer.toInt();\n  aVert = sVert.toInt();\n\n  return true;\n}\n\n// ======== SETUP ========\nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-BallPlatform\");\n\n  configServo(SERVO_IZQ, posIzq);\n  configServo(SERVO_DER, posDer);\n  configServo(SERVO_VERT,posVert);\n\n  Serial.println(\"ESP32 listo\");\n  tLastCmd = millis();\n}\n\n// ======== LOOP ========\nvoid loop(){\n\n  // --- Lectura Bluetooth no bloqueante ---\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n\n        if (msg == \"LOST\") {\n          // PC perdi\u00f3 mano/objetivo \u2192 \"centro\"\n          tgtIzq  = 90;\n          tgtDer  = 90;\n          tgtVert = 60;\n          Serial.println(\"Comando LOST: centro.\");\n\n        } else if (msg == \"ZERO\") {\n          // \ud83d\udd39 TODOS los servos a 180 f\u00edsicos\n          //    \u21d2 0 l\u00f3gico por el mapeo invertido\n          tgtIzq  = 0;\n          tgtDer  = 0;\n          tgtVert = 0;\n          Serial.println(\"Comando ZERO: servos \u2192 180\u00b0 fisico\");\n\n        } else {\n          int aIzq, aDer, aVert;\n          if (parseAngulos(msg, aIzq, aDer, aVert)) {\n            tgtIzq  = constrain(aIzq,  LIM_MIN, LIM_MAX);\n            tgtDer  = constrain(aDer,  LIM_MIN, LIM_MAX);\n            tgtVert = constrain(aVert, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; IZQ:%d DER:%d VERT:%d\\n\", tgtIzq, tgtDer, tgtVert);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al centro\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtIzq = 90;\n    tgtDer = 90;\n    tgtVert= 60;\n  }\n\n  aplicarRampa();\n  delay(1);\n}\n</code></pre> <pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\n\n# ========= BLUETOOTH =========\ndevice_mac = \"F0:24:F9:0C:4C:DE\"   # MISMA MAC DEL ESP32\nport = 1\n\n# ========= PAR\u00c1METROS SERVOS =========\nNEUT_IZQ  = 90\nNEUT_DER  = 90\nNEUT_VERT = 60\n\n# ----- MODO TEST (para exagerar el movimiento) -----\nTEST_MODE = True   # Cambia a False cuando ya quieras algo m\u00e1s fino\n\nif TEST_MODE:\n    # Mucho m\u00e1s movimiento de servos\n    MAX_SERVO_OFFSET_X = 50.0   # antes 40\n    MAX_SERVO_OFFSET_Y = 35.0   # antes 30\n\n    # Control m\u00e1s agresivo y SIN derivada (m\u00e1s f\u00e1cil ver el sentido)\n    KpX = 2.0\n    KdX = 0.0\n\n    KpY = 2.0\n    KdY = 0.0\nelse:\n    # Valores m\u00e1s tranquilos para uso normal\n    MAX_SERVO_OFFSET_X = 40.0\n    MAX_SERVO_OFFSET_Y = 30.0\n\n    KpX = 0.8\n    KdX = 0.2\n\n    KpY = 0.8\n    KdY = 0.2\n\n# ====== FLAGS DE ORIENTACI\u00d3N (LOS VAS CAMBIANDO EN VIVO) ======\nINVERT_X = False   # lo puedes cambiar con la tecla 'x'\nINVERT_Y = False   # lo puedes cambiar con la tecla 'y'\nSWAP_AXES = False  # si True, intercambia X&lt;-&gt;Y (tecla 's')\n\nalpha = 0.8          # filtro para derivada\nMIN_DT_CMD = 0.015   # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\nlast_time = time.time()\n\nlast_errx = 0.0\nlast_erry = 0.0\ndxf = 0.0\ndyf = 0.0\n\n# Centro calibrado de la plataforma (en p\u00edxeles de la imagen)\ncenterX = None\ncenterY = None\n\n# \u00daltima posici\u00f3n conocida de la pelota (para la tecla 'b')\nlast_ball_x = None\nlast_ball_y = None\n\n# ========= CONEXI\u00d3N BLUETOOTH =========\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\"\u2705 Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# ========= C\u00c1MARA (LA QUE VE LA PLATAFORMA) =========\n# Cambia 1 a 0 si tu otra c\u00e1mara es la que ve la plataforma\nvideo = cv2.VideoCapture(1)\n\n# ========= RANGO HSV PARA LA PELOTA (EJEMPLO: NARANJA) =========\nLOWER = np.array([10, 150, 120], np.uint8)\nUPPER = np.array([25, 255, 255], np.uint8)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    # Si la c\u00e1mara te da la imagen al rev\u00e9s y quieres voltearla:\n    # frame = cv2.flip(frame, 1)\n\n    h, w = frame.shape[:2]\n\n    # Si a\u00fan no hay centro calibrado, por defecto usa el centro de la imagen\n    if centerX is None or centerY is None:\n        centerX = w // 2\n        centerY = h // 2\n\n    now = time.time()\n    dt = now - last_time if now &gt; last_time else 0.01\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # --- Detecci\u00f3n de pelota por color ---\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask = cv2.inRange(hsv, LOWER, UPPER)\n    mask = cv2.erode(mask, kernel, iterations=2)\n    mask = cv2.dilate(mask, kernel, iterations=2)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    tiene_pelota = False\n\n    if len(contornos) &gt; 0:\n        c = max(contornos, key=cv2.contourArea)\n        (x, y), radio = cv2.minEnclosingCircle(c)\n\n        if radio &gt; 5:  # umbral m\u00ednimo para ruido\n            tiene_pelota = True\n\n            x = int(x)\n            y = int(y)\n            radio = int(radio)\n\n            # Guardamos \u00faltima posici\u00f3n de la pelota\n            last_ball_x = x\n            last_ball_y = y\n\n            # Dibujar pelota\n            cv2.circle(frame, (x, y), radio, (255, 0, 0), 2)\n            cv2.circle(frame, (x, y), 3, (255, 0, 0), -1)\n\n            # Dibujar l\u00edneas del centro calibrado\n            cx = int(centerX)\n            cy = int(centerY)\n            cv2.line(frame, (cx, 0), (cx, h), (0, 255, 255), 1)\n            cv2.line(frame, (0, cy), (w, cy), (0, 255, 255), 1)\n            cv2.circle(frame, (cx, cy), 5, (0, 255, 0), -1)  # centro calibrado\n\n            # Errores normalizados respecto al centro calibrado\n            errx_img = (x - cx) / (w / 2)   # derecha +, izquierda -\n            erry_img = (y - cy) / (h / 2)   # abajo +, arriba -\n\n            # Posible intercambio de ejes\n            if SWAP_AXES:\n                errx_raw = erry_img\n                erry_raw = errx_img\n            else:\n                errx_raw = errx_img\n                erry_raw = erry_img\n\n            # Mostrar errores crudos para debug\n            cv2.putText(frame, f\"Ex_raw:{errx_raw:+.2f} Ey_raw:{erry_raw:+.2f}\",\n                        (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (255, 255, 255), 2)\n\n            # --- Control PD ---\n            derx = (errx_raw - last_errx) / dt\n            dery = (erry_raw - last_erry) / dt\n\n            dxf = alpha * dxf + (1 - alpha) * derx\n            dyf = alpha * dyf + (1 - alpha) * dery\n\n            uX = KpX * errx_raw + KdX * dxf\n            uY = KpY * erry_raw + KdY * dyf\n\n            # Limitamos uX, uY a [-1,1]\n            uX = float(np.clip(uX, -1.0, 1.0))\n            uY = float(np.clip(uY, -1.0, 1.0))\n\n            # Invertir si hace falta (lo cambias en vivo con 'x' y 'y')\n            if INVERT_X:\n                uX = -uX\n            if INVERT_Y:\n                uY = -uY\n\n            # Offset de servos en grados\n            servo_off_X = uX * MAX_SERVO_OFFSET_X\n            servo_off_Y = uY * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos l\u00f3gicos absolutos\n            ang_izq  = NEUT_IZQ  - servo_off_X\n            ang_der  = NEUT_DER  + servo_off_X\n            ang_vert = NEUT_VERT - servo_off_Y\n\n            # Limitar a 0..180\n            ang_izq  = int(np.clip(ang_izq,  0, 180))\n            ang_der  = int(np.clip(ang_der,  0, 180))\n            ang_vert = int(np.clip(ang_vert, 0, 180))\n\n            cv2.putText(frame,\n                        f\"IZQ:{ang_izq} DER:{ang_der} VERT:{ang_vert}\",\n                        (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 255, 255), 2)\n\n            # --- Enviar comando ANG: ---\n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_izq},{ang_der},{ang_vert}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\"Error al enviar ANG:\", e)\n\n            last_errx = errx_raw\n            last_erry = erry_raw\n            last_time = now\n\n    if not tiene_pelota:\n        cv2.putText(frame, \"PELOTA NO DETECTADA\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Opcional: si pierdes la pelota, manda LOST para nivelar\n        if send_allowed:\n            try:\n                sock.send(b\"LOST\\n\")\n                last_cmd_time = now\n            except Exception as e:\n                print(\"Error al enviar LOST:\", e)\n\n    # Mostrar estado de flags\n    status = f\"invX:{INVERT_X}  invY:{INVERT_Y}  swap:{SWAP_AXES}  TEST:{TEST_MODE}\"\n    cv2.putText(frame, status, (10, h - 10),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)\n\n    cv2.imshow(\"Ball Balancing Control\", frame)\n    cv2.imshow(\"Mascara\", mask)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Tecla 'c' para nivelar manualmente (centro por firmware)\n        try:\n            sock.send(b\"LOST\\n\")\n            last_cmd_time = time.time()\n            print(\"Comando LOST enviado (plataforma al centro).\")\n        except Exception as e:\n            print(\"\u26a0\ufe0f Error al enviar LOST:\", e)\n    elif key == ord('x'):\n        INVERT_X = not INVERT_X\n        print(\"INVERT_X -&gt;\", INVERT_X)\n    elif key == ord('y'):\n        INVERT_Y = not INVERT_Y\n        print(\"INVERT_Y -&gt;\", INVERT_Y)\n    elif key == ord('s'):\n        SWAP_AXES = not SWAP_AXES\n        print(\"SWAP_AXES -&gt;\", SWAP_AXES)\n    elif key == ord('b'):\n        # Calibrar centro con la pelota en el centro f\u00edsico\n        if last_ball_x is not None and last_ball_y is not None:\n            centerX = last_ball_x\n            centerY = last_ball_y\n            print(f\"Centro calibrado en ({centerX}, {centerY})\")\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre></p>"},{"location":"PROYECTO%20FINAL/#6-conclusion","title":"6) Conclusi\u00f3n","text":"<p>El proyecto permiti\u00f3 comprobar que la combinaci\u00f3n de visi\u00f3n por computadora, control PD y servomotores puede implementarse de manera efectiva para mantener una pelota centrada sobre una plataforma inclinable. La separaci\u00f3n en dos modos de operaci\u00f3n \u2014detecci\u00f3n autom\u00e1tica por filtros de color y control manual mediante el seguimiento de la mano\u2014 permiti\u00f3 validar tanto la capacidad del sistema para operar en lazo cerrado como su respuesta a \u00f3rdenes directas. La integraci\u00f3n entre Python y el ESP32 funcion\u00f3 de forma estable y permiti\u00f3 el env\u00edo continuo de datos para corregir la posici\u00f3n en tiempo real. Se concluye que la plataforma es una base s\u00f3lida para futuras implementaciones m\u00e1s complejas, como controles PID completos, superficies m\u00f3viles de mayor tama\u00f1o, o incluso sistemas de estabilizaci\u00f3n aplicados a rob\u00f3tica m\u00f3vil.</p>"},{"location":"PR%C3%81CTICA%201/","title":"\ud83d\udcda Pr\u00e1ctica 1: Comunicaci\u00f3n Serial con ESP32-C6 en Arduino","text":""},{"location":"PR%C3%81CTICA%201/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un c\u00f3digo en Arduino IDE para establecer comunicaci\u00f3n serial con un ESP32-C6. Se explic\u00f3 el funcionamiento de los diferentes tipos de variables (<code>int</code>, <code>char</code>, <code>string</code>, <code>float</code>, <code>bool</code>) y la cantidad de datos que puede almacenar cada uno. Adem\u00e1s, se analizaron las diferencias entre los dos puertos de comunicaci\u00f3n del ESP32 (UART y USB nativo) y c\u00f3mo este recibe mensajes enviados desde el monitor serial.</li> </ul>"},{"location":"PR%C3%81CTICA%201/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender el funcionamiento b\u00e1sico de la comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Identificar y diferenciar los principales tipos de variables en Arduino.  </li> <li>Implementar un programa que permita recibir y mostrar mensajes en el monitor serial.  </li> <li>Analizar la diferencia entre el puerto UART (serial cl\u00e1sico) y el puerto USB nativo del ESP32.  </li> <li>Verificar la correcta recepci\u00f3n y env\u00edo de caracteres mediante pruebas pr\u00e1cticas.  </li> </ul>"},{"location":"PR%C3%81CTICA%201/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Uso del ESP32-C6 como dispositivo de comunicaci\u00f3n serial.  </li> <li>Configuraci\u00f3n del baud rate en el monitor serial.  </li> <li>Recepci\u00f3n y env\u00edo de mensajes en el IDE de Arduino.  </li> <li> <p>Explicaci\u00f3n te\u00f3rica de los tipos de variables y su uso en la pr\u00e1ctica.  </p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Programaci\u00f3n de librer\u00edas adicionales.  </li> <li>Uso de comunicaci\u00f3n inal\u00e1mbrica (Wi-Fi / Bluetooth).  </li> </ul>"},{"location":"PR%C3%81CTICA%201/#4-resultados","title":"4) Resultados","text":"<p>Durante la pr\u00e1ctica se logr\u00f3:  </p> <ul> <li>Recepci\u00f3n de datos seriales: El ESP32-C6 recibi\u00f3 correctamente mensajes enviados desde el monitor serial, aunque en un inicio aparecieron caracteres extra\u00f1os debido a un baud rate incorrecto. Ajustando la velocidad a 38400 baudios se solucion\u00f3 el problema.  </li> <li>Tipos de datos: </li> <li><code>int</code> \u2192 n\u00fameros enteros (16 bits).  </li> <li><code>char</code> \u2192 un car\u00e1cter (1 byte).  </li> <li><code>string</code> \u2192 cadena de caracteres (m\u00ednimo 16 bits, m\u00e1ximo variable).  </li> <li><code>float</code> \u2192 n\u00fameros con decimales (32 bits).  </li> <li><code>bool</code> \u2192 valores l\u00f3gicos (1 bit).  </li> <li>Puertos de comunicaci\u00f3n: </li> <li>UART (Universal Asynchronous Receiver-Transmitter): puerto serial tradicional, \u00fatil para depuraci\u00f3n o conexi\u00f3n con otros dispositivos.  </li> <li>USB nativo: permite programar directamente el microcontrolador y tambi\u00e9n enviar datos sin necesidad de un conversor externo.  </li> </ul> <p>C\u00f3digo Implementado</p> <pre><code>char msg;\n\nvoid setup() {\n  Serial.begin(38400);   // Inicializa comunicaci\u00f3n serial\n}\n\nvoid loop() {\n  if (Serial.available()) {   // Verifica si hay datos\n    msg = Serial.read();      // Lee el car\u00e1cter\n    Serial.print(msg);        // Lo reenv\u00eda al monitor\n  }\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%201/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica permiti\u00f3 comprender y verificar el flujo b\u00e1sico de comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. Se implement\u00f3 un programa de eco que recibi\u00f3 y reenvi\u00f3 caracteres desde el monitor serial, lo que facilit\u00f3 la validaci\u00f3n del canal de datos y el diagn\u00f3stico de errores de configuraci\u00f3n, como el problema de lectura con caracteres extra\u00f1os que se resolvi\u00f3 al ajustar el baud rate a 38400. Adem\u00e1s, se reforz\u00f3 la diferenciaci\u00f3n de tipos de datos y su papel al manipular informaci\u00f3n a nivel de firmware, as\u00ed como la distinci\u00f3n funcional entre el puerto UART y el USB nativo, entendiendo en qu\u00e9 contextos conviene usar cada uno (depuraci\u00f3n/interop vs. programaci\u00f3n y transferencia directa).</p> <p>En conjunto, se cumplieron los objetivos propuestos: identificaci\u00f3n de tipos de variables, implementaci\u00f3n de un receptor de mensajes por serial y an\u00e1lisis de los puertos de comunicaci\u00f3n del ESP32-C6. Como trabajo futuro, se sugiere extender el ejemplo para procesar cadenas completas (comandos), confirmar par\u00e1metros de temporizaci\u00f3n seg\u00fan el entorno (OS/driver/IDE) y conectar perif\u00e9ricos que respondan a instrucciones recibidas por serial, consolidando as\u00ed una base s\u00f3lida para pr\u00e1cticas posteriores con protocolos m\u00e1s complejos.</p>"},{"location":"PR%C3%81CTICA%202/","title":"\ud83d\udcda Pr\u00e1ctica 2: Control de LED NeoPixel con Arduino mediante comunicaci\u00f3n Serial.","text":""},{"location":"PR%C3%81CTICA%202/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 20/08/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se implementa un programa en Arduino para controlar un LED NeoPixel a trav\u00e9s de comandos enviados por el monitor serial. El usuario puede enviar instrucciones como \u201cred\u201d, \u201cgreen\u201d o \u201cblue\u201d y el LED cambiar\u00e1 su color de acuerdo al mensaje recibido. La librer\u00eda Adafruit_NeoPixel permite el manejo de este tipo de LEDs direccionables de manera sencilla.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"PR%C3%81CTICA%202/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento b\u00e1sico de un LED NeoPixel y su control mediante comunicaci\u00f3n serial en Arduino.</li> <li>Espec\u00edficos:</li> <li>Configurar el puerto serial para recibir datos desde el monitor de Arduino ID</li> <li>Implementar la librer\u00eda Adafruit_NeoPixel para inicializar y controlar el LED.</li> <li>Programar condiciones que permitan el cambio de color del LED en funci\u00f3n del mensaje recibido.</li> </ul>"},{"location":"PR%C3%81CTICA%202/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: El c\u00f3digo desarrollado tiene como finalidad recibir comandos de texto a trav\u00e9s del puerto serial y traducirlos en cambios de color en un LED NeoPixel.</li> </ul> <p>Solo se controla un LED (NUMPIXELS = 1).</p> <p>-El usuario puede escribir \u201cred\u201d, \u201cgreen\u201d o \u201cblue\u201d en el monitor serial.</p> <p>-Cada mensaje recibido activa el LED con la intensidad y color definido.</p> <p>-Se incorpora un retardo de 1 segundo para visualizar claramente cada cambio.</p> <p>-La l\u00f3gica puede escalarse f\u00e1cilmente para m\u00e1s LEDs o m\u00e1s colores..</p>"},{"location":"PR%C3%81CTICA%202/#4-resultados","title":"4) Resultados","text":"<p>Al realizar la pr\u00e1ctica se comprob\u00f3 que el sistema respondi\u00f3 de manera adecuada a los comandos enviados desde el monitor serial. Cada vez que se ingres\u00f3 la palabra \u201cred\u201d, el LED NeoPixel se ilumin\u00f3 en color rojo con la intensidad programada; al escribir \u201cgreen\u201d, el LED cambi\u00f3 correctamente a color verde; y al introducir \u201cblue\u201d, se encendi\u00f3 en color azul. C\u00f3digo El retardo de un segundo facilit\u00f3 la observaci\u00f3n de cada cambio de color antes de recibir un nuevo comando, lo que permiti\u00f3 validar visualmente el funcionamiento del programa. Adem\u00e1s, se constat\u00f3 que el uso del car\u00e1cter coma (,) como delimitador en la lectura de cadenas evit\u00f3 errores de interpretaci\u00f3n en los mensajes.</p> <p></p> <p>En general, el comportamiento del LED fue estable, sin presentar fallos de comunicaci\u00f3n ni bloqueos durante las pruebas, lo cual confirma la correcta implementaci\u00f3n de la librer\u00eda y de la l\u00f3gica de control.</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"PR%C3%81CTICA%202/#6-codigo","title":"6) C\u00f3digo","text":"<pre><code>// NeoPixel Ring simple sketch (c) 2013 Shae Erisson\n// Released under the GPLv3 license to match the rest of the\n// Adafruit NeoPixel library\n\n#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n #include &lt;avr/power.h&gt; // Required for 16 MHz Adafruit Trinket\n#endif\n\n// Which pin on the Arduino is connected to the NeoPixels?\n#define PIN 8    // On Trinket or Gemma, suggest changing this to 1\n\n// How many NeoPixels are attached to the Arduino?\n#define NUMPIXELS 1 // Popular NeoPixel ring size\n\n// When setting up the NeoPixel library, we tell it how many pixels,\n// and which pin to use to send signals. Note that for older NeoPixel\n// strips you might need to change the third parameter -- see the\n// strandtest example for more information on possible values.\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n#define DELAYVAL 500 // Time (in milliseconds) to pause between pixels\n\nString msj=\"\";\n\nvoid setup() {\n   Serial.begin(115200);//Inicia Serial a 115200 bauds o 115200 char/s\n  pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED)\n}\n\nvoid loop() {\n\n   if(Serial.available()&gt;0){ //Entrar al if solo si se recibe algo por el serial\n    msj = Serial.readStringUntil(',');//Ciclo hasta leer el char marcado\n    Serial.println(msj); //Imprime el comando recibido\n  }\n\n  if(msj==\"red\")\n  {\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(150, 0, 0));\n    pixels.show();   // Send the updated pixel colors to the hardware.\n    delay (1000);\n  }\n\n  else if(msj==\"green\"){\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(0, 150, 0));\n    pixels.show();\n    delay (1000);\n  }\n  else if(msj==\"blue\"){\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(0, 0, 150));\n    pixels.show();\n    delay (1000);\n  }\n\n\n\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%202/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>Con esta pr\u00e1ctica se demostr\u00f3 el uso b\u00e1sico de la librer\u00eda Adafruit_NeoPixel para controlar LEDs direccionables mediante comunicaci\u00f3n serial. El programa permite al usuario interactuar directamente con el hardware enviando comandos simples desde el monitor serial, logrando as\u00ed un cambio de color en el LED. Esta l\u00f3gica se puede ampliar a tiras LED m\u00e1s grandes y a una gama m\u00e1s amplia de colores, lo cual representa una aplicaci\u00f3n fundamental en proyectos de iluminaci\u00f3n decorativa, rob\u00f3tica y se\u00f1alizaci\u00f3n.</p>"},{"location":"PR%C3%81CTICA%203/","title":"\ud83d\udcda Pr\u00e1ctica 3: Control de LED NeoPixel por comandos R,G,B (ESP32-C6 + Arduino IDE)","text":""},{"location":"PR%C3%81CTICA%203/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un programa en Arduino IDE para controlar un NeoPixel conectado a un ESP32-C6 recibiendo comandos por Serial en el formato <code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code> (0\u2013255). Se reforz\u00f3 el manejo de tipos de variables, el uso de la librer\u00eda Adafruit_NeoPixel y la diferencia pr\u00e1ctica entre UART y USB nativo.</li> </ul> <p>Tip: Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"PR%C3%81CTICA%203/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender y aplicar la comunicaci\u00f3n serial en el ESP32-C6 para controlar un LED NeoPixel mediante comandos <code>R,G,B</code>.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Configurar el puerto Serial y verificar su velocidad.  </li> <li>Parsear un comando de texto con tres canales (R, G, B).  </li> <li>Limitar cada canal al rango v\u00e1lido 0\u2013255 y actualizar el color del NeoPixel.  </li> <li>Comparar el uso de USB nativo frente a UART para depuraci\u00f3n y pruebas.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Control de 1 LED NeoPixel (<code>NUMPIXELS = 1</code>).  </li> <li>Recepci\u00f3n de comandos por Monitor Serial (<code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code>).  </li> <li> <p>Ajuste de baud rate y verificaci\u00f3n de eco.</p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Uso de Wi-Fi / Bluetooth.  </li> <li>Efectos avanzados o animaciones en tiras LED.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#4-resultados","title":"4) Resultados","text":"<ul> <li>Recepci\u00f3n de comandos seriales y aplicaci\u00f3n inmediata del color en el NeoPixel.  </li> <li>Velocidad usada: 115200 baudios (coincidente entre <code>Serial.begin</code> y Monitor Serial).  </li> <li>Validaci\u00f3n de entrada: cada canal se restringe con <code>constrain(...)</code> a 0\u2013255.  </li> <li>Ejemplos probados: <code>R120,G110,B10</code>, <code>R255,G0,B0</code>, <code>R0,G0,B255</code>.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#5-protocolo-de-comandos-y-pruebas","title":"5) Protocolo de comandos y pruebas","text":"<ul> <li>Formato: <code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code> </li> <li>Rango: <code>0\u2013255</code> por canal.  </li> <li>Delimitaci\u00f3n: valores separados por coma y finalizados con Enter (<code>\\n</code>).  </li> </ul> <p>Pruebas sugeridas - <code>R255,G0,B0</code> (rojo) - <code>R0,G255,B0</code> (verde) - <code>R0,G0,B255</code> (azul) - <code>R255,G191,B0</code> (\u00e1mbar) - <code>R10,G10,B10</code> (atenuado)</p>"},{"location":"PR%C3%81CTICA%203/#6-codigo-implementado","title":"6) C\u00f3digo Implementado","text":"<pre><code>#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n  #include &lt;avr/power.h&gt;\n#endif\n\n#define PIN 8\n#define NUMPIXELS 1\n\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nString cmd = \"\";\nint r = 0, g = 0, b = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  pixels.begin();\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) {\n    cmd = Serial.readStringUntil('\\n');\n    Serial.println(\"Msj recibido: \" + cmd);\n\n    int pos1 = cmd.indexOf(',');      \n    int pos2 = cmd.indexOf(',', pos1 + 1);\n\n    String rPart = cmd.substring(0, pos1);                \n    String gPart = cmd.substring(pos1 + 1, pos2);        \n    String bPart = cmd.substring(pos2 + 1);              \n\n    // Extrae el n\u00famero despu\u00e9s de la letra (R/G/B) y limita a 0-255\n    r = constrain(rPart.substring(1).toInt(), 0, 255);\n    g = constrain(gPart.substring(1).toInt(), 0, 255);\n    b = constrain(bPart.substring(1).toInt(), 0, 255);\n\n    pixels.clear();\n    pixels.setPixelColor(0, pixels.Color(r, g, b));\n    pixels.show();\n  }\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%203/#7-conclusiones","title":"7) Conclusiones","text":"<p>La pr\u00e1ctica consolid\u00f3 el control determinista de un NeoPixel v\u00eda comandos seriales R,G,B en el ESP32-C6. Se valid\u00f3 el parseo de texto con separaci\u00f3n por comas y el mapeo de cada canal a su rango permitido (0\u2013255), reflej\u00e1ndose de inmediato en el LED mediante Adafruit_NeoPixel. La sincron\u00eda de baudios (115200) entre Serial.begin y el Monitor Serial evit\u00f3 errores de lectura, y la comparaci\u00f3n entre USB nativo y UART aclar\u00f3 escenarios de uso (programaci\u00f3n/depuraci\u00f3n directa vs. interoperabilidad con otros dispositivos). En suma, se cumplieron los objetivos: configuraci\u00f3n del puerto, interpretaci\u00f3n de comandos, limitaci\u00f3n de rango y actualizaci\u00f3n correcta del color.</p> <p>Como mejora futura, se recomienda:</p> <p>Robustecer el protocolo: tolerar espacios y min\u00fasculas, manejar \\r\\n, validar formato (faltas de coma o letras) y enviar ACK/ERROR al host.</p> <p>Experiencia visual: agregar brillo global y correcci\u00f3n gamma, y extender a m\u00e1s p\u00edxeles/animaciones manteniendo tiempos no bloqueantes.</p> <p>Fiabilidad el\u00e9ctrica: asegurar alimentaci\u00f3n estable del LED (condensador de 100\u20131000 \u00b5F en 5 V) y cuidar la compatibilidad de niveles de datos (3.3 V suele funcionar, pero considerar un level shifter en tiras largas).</p> <p>Estas extensiones convertir\u00e1n el ejercicio en una base s\u00f3lida para protocolos m\u00e1s ricos (p. ej., comandos con brillo, efectos o m\u00faltiples LEDs) y para integrar perif\u00e9ricos que reaccionen a instrucciones seriales en tiempo real.</p>"},{"location":"PR%C3%81CTICA%204/","title":"\ud83d\udcda Pr\u00e1ctica 4: Lectura de Aceler\u00f3metro MPU6050 con Arduino","text":""},{"location":"PR%C3%81CTICA%204/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se implementa un programa en Arduino para leer datos de un aceler\u00f3metro y giroscopio MPU6050 mediante comunicaci\u00f3n I2C. El sistema recoge informaci\u00f3n de aceleraci\u00f3n en tres ejes (X, Y, Z), velocidades angulares (giroscopio) y temperatura interna del sensor, mostrando los valores por el monitor serial.</li> </ul>"},{"location":"PR%C3%81CTICA%204/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento b\u00e1sico del sensor MPU6050 y su lectura mediante la comunicaci\u00f3n I2C en Arduino..</li> <li>Espec\u00edficos:</li> <li>Inicializar correctamente el sensor MPU6050 utilizando la interfaz I2C.</li> <li>Leer y convertir los datos de aceleraci\u00f3n, temperatura y giroscopio</li> <li>Mostrar los valores en el monitor serial para su an\u00e1lisis y visualizaci\u00f3n.</li> </ul>"},{"location":"PR%C3%81CTICA%204/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: a pr\u00e1ctica se enfoca en la lectura y visualizaci\u00f3n de los datos del sensor MPU6050, el cual proporciona informaci\u00f3n \u00fatil de aceleraci\u00f3n, temperatura y velocidad angular.</li> </ul> <p>-Los datos se obtienen usando comunicaci\u00f3n I2C a trav\u00e9s de la librer\u00eda Wire.</p> <p>-La salida de datos es continua y se presenta en el monitor serial cada segundo.</p> <p>-No se utiliza ninguna librer\u00eda externa espec\u00edfica para MPU6050, se accede directamente a los registros del sensor.</p> <p>-Los valores obtenidos son procesados para mostrar aceleraci\u00f3n en \"g\", temperatura en \u00b0C y giroscopio en \u00b0/s.</p> <p>-_Los valores obtenidos son procesados para mostrar:</p> <p><code>Aceleraci\u00f3n en g</code> <code>Temperatura en \u00b0C</code> <code>Giroscopio en \u00b0/s</code>_</p>"},{"location":"PR%C3%81CTICA%204/#4-resultados","title":"4) Resultados","text":"<p>Para esta pr\u00e1ctica, se consult\u00f3 la hoja de datos del MPU6050, donde se especifican las direcciones de los registros internos. Cada tipo de dato se encuentra en registros consecutivos:</p> Tipo de Dato Direcci\u00f3n Base Bytes le\u00eddos Descripci\u00f3n Aceler\u00f3metro <code>0x3B</code> 6 bytes X (2), Y (2), Z (2) Temperatura <code>0x41</code> 2 bytes Solo 1 dato (valor de 16 bits) Giroscopio <code>0x43</code> 6 bytes X (2), Y (2), Z (2) <p>Al ejecutar el programa cargado en el Arduino, se pudo observar que la lectura de datos del sensor MPU6050 se realiz\u00f3 de manera satisfactoria. Los valores de aceleraci\u00f3n en los ejes X, Y y Z respondieron correctamente al mover f\u00edsicamente el sensor, mostrando cambios en tiempo real en el monitor serial. Esto confirm\u00f3 que la configuraci\u00f3n de los registros internos del sensor y la escala aplicada a los datos fue adecuada, permitiendo representar la aceleraci\u00f3n en unidades de \"g\".</p> <p>El programa utiliza la librer\u00eda Wire.h para establecer la comunicaci\u00f3n I2C entre el Arduino y el sensor MPU6050. Esta comunicaci\u00f3n requiere una direcci\u00f3n del dispositivo, en este caso 0x69, que corresponde al sensor. Cada tipo de dato (aceleraci\u00f3n, giroscopio, temperatura) se encuentra en una posici\u00f3n espec\u00edfica de memoria interna del sensor, llamada registro. El programa accede a esos registros para leer la informaci\u00f3n.Primero, en el setup(), se inicializa la comunicaci\u00f3n I2C (Wire.begin()) y el monitor serial (Serial.begin(115200)). Luego, se despierta el sensor escribiendo 0x00 en el registro de encendido 0x6B.El programa Lee la aceleraci\u00f3n, luego la temperatura y por ultimo la velocidad del giroscopio, ajustando la escala a cada dato.</p> <p></p> <p>En resumen, la pr\u00e1ctica permiti\u00f3 obtener con \u00e9xito los tres tipos de datos proporcionados por el sensor: aceleraci\u00f3n, velocidad angular y temperatura, validando tanto la lectura directa de registros como el procesamiento correcto de los datos. Adem\u00e1s, se verific\u00f3 la importancia de interpretar los datos como enteros con signo y de seguir la documentaci\u00f3n oficial (datasheet) para aplicar correctamente las f\u00f3rmulas y las direcciones de memoria.</p>"},{"location":"PR%C3%81CTICA%204/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;Wire.h&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#define MPU_ADDR 0x69\n#define reg_accelx 0x3b\n#define reg_accely 0x3d\n#define reg_accelz 0x3f\n#define reg_temp1 0x41\n#define reg_girox 0x43\n#define reg_giroy 0x45\n#define reg_giroz 0x47\nint x_1=0;\nint x_2=0;\nint y_1=0;\nint y_2=0;\nint z_1=0;\nint z_2=0;\nint girox_1=0;\nint girox_2=0;\nint giroy_1=0;\nint giroy_2=0;\nint giroz_1=0;\nint giroz_2=0;\nint temp_1=0;\nint temp_2=0;\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Wire.begin();\n  Serial.begin(115200);\n  Wire.beginTransmission(MPU_ADDR);\n  Wire.write(0x6b);\n  Wire.write(0x00);\n  Wire.endTransmission(true);\n\n\n\n}\n\nvoid loop() {\n  Wire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_accelx); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,6,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    x_1 = Wire.read();\n    x_2 = Wire.read();\n    y_1 = Wire.read();\n    y_2 = Wire.read();\n    z_1 = Wire.read();\n    z_2 = Wire.read();\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\n  Wire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_temp1); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,2,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    temp_1 = Wire.read();\n    temp_2 = Wire.read();\n\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\nWire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_girox); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,6,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    girox_1 = Wire.read();\n    girox_2 = Wire.read();\n    giroy_1 = Wire.read();\n    giroy_2 = Wire.read();\n    giroz_1 = Wire.read();\n    giroz_2 = Wire.read();\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\n\n  int completo = (x_1 &lt;&lt;8) | x_2;\n  float aceleracion_x = (float)completo / 16384.0;\n  Serial.print(\"ACX:\");\n  Serial.println(aceleracion_x);\n\n\n\n  int16_t completo1 = (y_1 &lt;&lt;8) | y_2;\n  float aceleracion_y = (float)completo1 / 16384.0;\n  Serial.print(\"ACY:\");\n  Serial.println(aceleracion_y);\n\n  int16_t completo2 = (z_1 &lt;&lt;8) | z_2;\n  float aceleracion_z = (float)completo2 / 16384.0;\n  Serial.print(\"ACZ:\");\n  Serial.println(aceleracion_z);\n\n  int16_t completo4 = (girox_1 &lt;&lt;8) | girox_2;\n  float giro_x = (float)completo4 / 131.0;\n  Serial.print(\"GIROX:\");\n  Serial.println(giro_x);\n\n  int16_t completo5 = (giroy_1 &lt;&lt;8) | giroy_2;\n  float giro_y = (float)completo5 / 131.0;\n  Serial.print(\"GIROY:\");\n  Serial.println(giro_y);\n\n  int16_t completo6 = (giroz_1 &lt;&lt;8) | giroz_2;\n  float giro_z = (float)completo6 / 131.0;\n  Serial.print(\"GIROZ:\");\n  Serial.println(giro_z);\n\n  int16_t completo3 = (temp_1 &lt;&lt;8) | temp_2;\n  float temperatura_1 = (float)completo3 / 340.0 + 36.53;\n  Serial.print(\"TEMP:\");\n  Serial.println(temperatura_1);\n\n\n  delay (1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%204/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>_Esta pr\u00e1ctica permiti\u00f3 poner en funcionamiento un sensor MPU6050 sin el uso de librer\u00edas externas espec\u00edficas, lo cual facilita una comprensi\u00f3n m\u00e1s profunda del protocolo de comunicaci\u00f3n I2C y de la estructura de datos del sensor. La obtenci\u00f3n de valores crudos y su posterior escalado muestran c\u00f3mo se puede traducir informaci\u00f3n binaria en datos f\u00edsicos \u00fatiles.Los conocimientos adquiridos pueden aplicarse en proyectos que involucren navegaci\u00f3n, rob\u00f3tica, drones, estabilizadores, entre otros. La pr\u00e1ctica tambi\u00e9n sienta las bases para integrar m\u00faltiples sensores y realizar an\u00e1lisis de movimiento m\u00e1s avanzados.</p>"},{"location":"PR%C3%81CTICA%205/","title":"\ud83d\udcda Pr\u00e1ctica 5: ESP32-C6 como Beacon (BLE Advertising)","text":""},{"location":"PR%C3%81CTICA%205/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica configuramos el ESP32-C6 como un dispositivo BLE que anuncia su presencia (Advertising). Se crea un servidor BLE, un servicio con UUID propio y se inicia el anuncio para que pueda ser detectado por apps como nRF Connect o LightBlue.</li> </ul>"},{"location":"PR%C3%81CTICA%205/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Inicializar el stack BLE del ESP32-C6 con un nombre de dispositivo.</li> <li>Crear un servidor BLE, un servicio y una caracter\u00edstica b\u00e1sica.</li> <li>Iniciar y comprobar el Advertising desde el Monitor Serial y el tel\u00e9fono.</li> </ul>"},{"location":"PR%C3%81CTICA%205/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>Cable USB  </li> <li>Arduino IDE (core ESP32 instalado)  </li> <li>App BLE en smartphone (p. ej., nRF Connect / LightBlue)</li> </ul>"},{"location":"PR%C3%81CTICA%205/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\n// ====== Configuraci\u00f3n ======\nstatic const char* DEVICE_NAME = \"AKDevice\";  // Nombre que ver\u00e1s en el escaneo\n#define SERVICE_UUID        \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-5678-90ab-cdef-1234567890ab\"\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n\n  // 1) Inicializa BLE con nombre\n  BLEDevice::init(DEVICE_NAME);\n\n  // 2) Crea servidor y servicio\n  BLEServer*      pServer  = BLEDevice::createServer();\n  BLEService*     pService = pServer-&gt;createService(SERVICE_UUID);\n\n  // 3) Caracter\u00edstica de ejemplo (Lectura/Escritura)\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ   |\n      BLECharacteristic::PROPERTY_WRITE\n  );\n  pCharacteristic-&gt;setValue(\"Hola BLE\");\n\n  // 4) Inicia el servicio\n  pService-&gt;start();\n\n  // 5) Configura el advertising\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID);   // Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);          // Info extra en la respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);          // Par\u00e1metros recomendados\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  // 6) Inicia advertising\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising started\");\n}\n\nvoid loop() {\n  // Nada en el loop; el anuncio corre en segundo plano\n  delay(1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%205/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica demostr\u00f3 el uso b\u00e1sico de BLE en el ESP32-C6 configur\u00e1ndolo como beacon publicitario: se inicializ\u00f3 el dispositivo con nombre propio, se cre\u00f3 un servidor GATT con servicio y caracter\u00edstica y se inici\u00f3 el advertising incluyendo el UUID del servicio y scan response, lo que permiti\u00f3 descubrir y verificar el dispositivo desde apps m\u00f3viles (p. ej., nRF Connect / LightBlue). Con ello, se cumpli\u00f3 el objetivo de exponer presencia y metadatos por BLE y confirmar, desde el Monitor Serial y el smartphone, que el anuncio permanece activo en segundo plano.</p> <p>Como mejoras futuras se sugiere:</p> <p>Como mejoras futuras se sugiere:</p> <ul> <li>Ajustar par\u00e1metros de advertising (intervalo, potencia TX) para balancear alcance vs. consumo y observar el impacto en RSSI.</li> <li>Agregar datos en el payload (Manufacturer Data o Service Data) o adoptar formatos est\u00e1ndar como iBeacon/Eddystone cuando aplique.</li> <li>Gestionar estados: detener/relanzar advertising al conectar, y agregar callbacks del servidor para eventos (onConnect/onDisconnect).</li> <li>Seguridad y privacidad: habilitar MAC aleatoria, definir propiedades/permiso de la caracter\u00edstica (read/write/notify) y, si procede, emparejamiento.</li> <li>Escalabilidad: m\u00faltiples caracter\u00edsticas/servicios y notificaciones (notify/indicate) para aplicaciones interactivas m\u00e1s all\u00e1 del simple anuncio.</li> </ul>"},{"location":"PR%C3%81CTICA%206/","title":"\ud83d\udcda Pr\u00e1ctica 6: ESP32-C6 como Beacon (BLE Advertising)","text":""},{"location":"PR%C3%81CTICA%206/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica configuramos el ESP32-C6 como un dispositivo BLE que anuncia su presencia (Advertising). Se crea un servidor BLE, un servicio con UUID propio y se inicia el anuncio para que pueda ser detectado por apps como nRF Connect o LightBlue.</li> </ul>"},{"location":"PR%C3%81CTICA%206/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Inicializar el stack BLE del ESP32-C6 con un nombre de dispositivo.</li> <li>Crear un servidor BLE, un servicio y una caracter\u00edstica b\u00e1sica.</li> <li>Iniciar y comprobar el Advertising desde el Monitor Serial y el tel\u00e9fono.</li> </ul>"},{"location":"PR%C3%81CTICA%206/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>Cable USB  </li> <li>Arduino IDE (core ESP32 instalado)  </li> <li>App BLE en smartphone (p. ej., nRF Connect / LightBlue)</li> </ul>"},{"location":"PR%C3%81CTICA%206/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\n// ====== Configuraci\u00f3n ======\nstatic const char* DEVICE_NAME = \"AKDevice\";  // Nombre que ver\u00e1s en el escaneo\n#define SERVICE_UUID        \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-5678-90ab-cdef-1234567890ab\"\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n\n  // 1) Inicializa BLE con nombre\n  BLEDevice::init(DEVICE_NAME);\n\n  // 2) Crea servidor y servicio\n  BLEServer*      pServer  = BLEDevice::createServer();\n  BLEService*     pService = pServer-&gt;createService(SERVICE_UUID);\n\n  // 3) Caracter\u00edstica de ejemplo (Lectura/Escritura)\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ   |\n      BLECharacteristic::PROPERTY_WRITE\n  );\n  pCharacteristic-&gt;setValue(\"Hola BLE\");\n\n  // 4) Inicia el servicio\n  pService-&gt;start();\n\n  // 5) Configura el advertising\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID);   // Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);          // Info extra en la respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);          // Par\u00e1metros recomendados\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  // 6) Inicia advertising\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising started\");\n}\n\nvoid loop() {\n  // Nada en el loop; el anuncio corre en segundo plano\n  delay(1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%206/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica demostr\u00f3 el uso b\u00e1sico de BLE en el ESP32-C6 configur\u00e1ndolo como beacon publicitario: se inicializ\u00f3 el dispositivo con nombre propio, se cre\u00f3 un servidor GATT con servicio y caracter\u00edstica y se inici\u00f3 el advertising incluyendo el UUID del servicio y scan response, lo que permiti\u00f3 descubrir y verificar el dispositivo desde apps m\u00f3viles (p. ej., nRF Connect / LightBlue). Con ello, se cumpli\u00f3 el objetivo de exponer presencia y metadatos por BLE y confirmar, desde el Monitor Serial y el smartphone, que el anuncio permanece activo en segundo plano.</p> <p>Como mejoras futuras se sugiere:</p> <p>Como mejoras futuras se sugiere:</p> <ul> <li>Ajustar par\u00e1metros de advertising (intervalo, potencia TX) para balancear alcance vs. consumo y observar el impacto en RSSI.</li> <li>Agregar datos en el payload (Manufacturer Data o Service Data) o adoptar formatos est\u00e1ndar como iBeacon/Eddystone cuando aplique.</li> <li>Gestionar estados: detener/relanzar advertising al conectar, y agregar callbacks del servidor para eventos (onConnect/onDisconnect).</li> <li>Seguridad y privacidad: habilitar MAC aleatoria, definir propiedades/permiso de la caracter\u00edstica (read/write/notify) y, si procede, emparejamiento.</li> <li>Escalabilidad: m\u00faltiples caracter\u00edsticas/servicios y notificaciones (notify/indicate) para aplicaciones interactivas m\u00e1s all\u00e1 del simple anuncio.</li> </ul>"},{"location":"PR%C3%81CTICA%207/","title":"\ud83d\udcda Pr\u00e1ctica 7: Control de LEDs con ESP32 mediante Servidor Web","text":""},{"location":"PR%C3%81CTICA%207/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se configur\u00f3 un ESP32 como servidor web para controlar tres LEDs a trav\u00e9s de una red WiFi local. Se implement\u00f3 una interfaz web sencilla que permite encender y apagar un LED principal mediante un bot\u00f3n en la p\u00e1gina, mientras que los otros LEDs pueden controlarse utilizando diferentes rutas URL. El sistema demuestra c\u00f3mo integrar redes inal\u00e1mbricas con hardware f\u00edsico en proyectos de IoT.</li> </ul>"},{"location":"PR%C3%81CTICA%207/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento de un servidor web en el ESP32 y su aplicaci\u00f3n en el control remoto de dispositivos electr\u00f3nicos.</li> <li>Espec\u00edficos:</li> <li>Configurar el ESP32 para conectarse a una red WiFi.</li> <li>Implementar un servidor web que responda a diferentes rutas (URLs).</li> <li>Encender y apagar LEDs mediante botones en una p\u00e1gina web y mediante acceso directo a URL.</li> </ul>"},{"location":"PR%C3%81CTICA%207/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:  -Control de tres LEDs independientes a trav\u00e9s de rutas espec\u00edficas en el servidor.</li> </ul> <p>-Prueba del sistema accediendo desde un navegador web en la misma red.</p> <p>-Conexi\u00f3n del ESP32 a una red WiFi local.</p> <p>-No se implementa autenticaci\u00f3n ni seguridad en el servidor web.</p> <p>-No se utilizan librer\u00edas externas de servidores avanzados, \u00fanicamente la librer\u00eda nativa WebServer.h.</p> <p>-El control se limita a encendido y apagado, sin regulaci\u00f3n de intensidad (PWM).</p>"},{"location":"PR%C3%81CTICA%207/#4-resultados","title":"4) Resultados","text":"<p>Al cargar el programa en el ESP32 y abrir el monitor serial, se muestra la direcci\u00f3n IP asignada por la red WiFi, la cual se introduce en el navegador para acceder al servidor.</p> <p>La p\u00e1gina principal permite controlar un LED mediante un bot\u00f3n que cambia din\u00e1micamente su estado de \u201cON\u201d a \u201cOFF\u201d. Para los otros dos LEDs, se accede a trav\u00e9s de rutas espec\u00edficas (/on1, /off1, /on2, /off2) en la URL, lo cual permite verificar el funcionamiento del servidor al interpretar diferentes solicitudes HTTP.</p> <p>El funcionamiento observado fue el siguiente: Al presionar el bot\u00f3n en la p\u00e1gina, el LED conectado al pin 20 cambia entre encendido y apagado. Al introducir manualmente la ruta /on1 o /off1, el LED en el pin 19 responde correctamente. De igual manera, con las rutas /on2 y /off2 se controla el LED del pin 21 Esto valida la correcta integraci\u00f3n entre la programaci\u00f3n del ESP32, el servidor web y el hardware f\u00edsico.</p> <p></p>"},{"location":"PR%C3%81CTICA%207/#_1","title":"\ud83d\udcda Pr\u00e1ctica 7: Control de LEDs con ESP32 mediante Servidor Web","text":""},{"location":"PR%C3%81CTICA%207/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\nconst char* ssid = \"iPhone\";\nconst char* password = \"karennajera\";\n\nWebServer server(80);\n\nconst int ledPin = 20;  \nconst int ledPin1 = 19;\nconst int ledPin2 = 21;\nString ledState = \"OFF\";\nString ledState1 = \"OFF\";\nString ledState2 = \"OFF\";\n\nvoid handleRoot() {\n  String html = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='UTF-8'&gt;&lt;title&gt;ESP32 LED Control&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\";\n  html += \"&lt;h1&gt;ESP32 LED Control&lt;/h1&gt;\";\n  html += \"&lt;p&gt;LED is \" + ledState + \"&lt;/p&gt;\";\n  if (ledState == \"OFF\")\n    html += \"&lt;a href=\\\"/on\\\"&gt;&lt;button&gt;Turn On&lt;/button&gt;&lt;/a&gt;\";\n  else\n    html += \"&lt;a href=\\\"/off\\\"&gt;&lt;button&gt;Turn Off&lt;/button&gt;&lt;/a&gt;\";\n  html += \"&lt;/body&gt;&lt;/html&gt;\";\n  server.send(200, \"text/html\", html);\n}\n\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleRoot();\n}\n\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleRoot();\n}\n\nvoid handleOn1() {\n  digitalWrite(ledPin1, HIGH);\n  ledState1 = \"ON\";\n  handleRoot();\n}\nvoid handleOff1() {\n  digitalWrite(ledPin1, LOW);\n  ledState1 = \"OFF\";\n  handleRoot();\n}\nvoid handleOn2() {\n  digitalWrite(ledPin2, HIGH);\n  ledState2 = \"ON\";\n  handleRoot();\n}\nvoid handleOff2() {\n  digitalWrite(ledPin2, LOW);\n  ledState2 = \"OFF\";\n  handleRoot();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  pinMode(ledPin1, OUTPUT);\n  pinMode(ledPin2, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  digitalWrite(ledPin1, LOW);\n  digitalWrite(ledPin2, LOW);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n  Serial.println(WiFi.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/on\", handleOn);\n  server.on(\"/off\", handleOff);\n  server.on(\"/on1\", handleOn1);\n  server.on(\"/off1\", handleOff1);\n  server.on(\"/on2\", handleOn2);\n  server.on(\"/off2\", handleOff2);\n\n  server.begin();\n  Serial.println(\"Server started\");\n}\n\nvoid loop() {\n  server.handleClient();\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%207/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 comprobar que el ESP32 puede actuar como un servidor web capaz de controlar perif\u00e9ricos en tiempo real. A trav\u00e9s de una interfaz sencilla en HTML, se logr\u00f3 el encendido y apagado de LEDs de forma remota desde cualquier dispositivo conectado a la misma red. Este ejercicio constituye un ejemplo b\u00e1sico de aplicaciones IoT, donde los microcontroladores conectados a internet permiten interactuar con el entorno f\u00edsico. Los conocimientos adquiridos son fundamentales para proyectos m\u00e1s complejos como automatizaci\u00f3n del hogar, control de maquinaria industrial o monitoreo de sistemas.</p>"},{"location":"PR%C3%81CTICA%208/","title":"\ud83d\udcda Pr\u00e1ctica 8: Control de LEDs con ESP32 mediante Servidor Web Interactivo","text":""},{"location":"PR%C3%81CTICA%208/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 29/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se configur\u00f3 un ESP32 como servidor web para controlar dos LEDs mediante sliders (control PWM) y uno adicional a trav\u00e9s de un bot\u00f3n de encendido/apagado en una interfaz web. Tambi\u00e9n se incorpor\u00f3 una caja de texto para enviar datos al ESP32 desde la misma p\u00e1gina. Todo esto permite simular una interfaz de control b\u00e1sica para un sistema embebido conectado a red, sentando las bases para aplicaciones IoT.</li> </ul>"},{"location":"PR%C3%81CTICA%208/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender e implementar un servidor web sobre el ESP32 que permita el control interactivo de perif\u00e9ricos en tiempo real a trav\u00e9s de una interfaz web.</li> <li>Espec\u00edficos:</li> <li>Configurar una p\u00e1gina HTML embebida que incluya controles interactivos como sliders, botones y cajas de texto.</li> <li>Implementar funciones en el servidor web para recibir valores y aplicarlos al hardware f\u00edsico (pines PWM y digitales).</li> <li>Utilizar funciones de mapeo PWM para controlar brillo o velocidad de motores.</li> </ul>"},{"location":"PR%C3%81CTICA%208/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:  -Control de dos salidas PWM mediante sliders en una interfaz web.</li> </ul> <p>-Control de un LED (ON/OFF) mediante un bot\u00f3n en la misma p\u00e1gina.</p> <p>-Recepci\u00f3n de texto desde una caja de entrada y su impresi\u00f3n en el monitor serial.</p> <p>-No se implementa autenticaci\u00f3n ni seguridad en el servidor web.</p> <p>-No se utilizan librer\u00edas externas avanzadas, \u00fanicamente WiFi.h y WebServer.h..</p> <p>-No se contempla la regulaci\u00f3n anal\u00f3gica directa del LED controlado por bot\u00f3n (solo ON/OFF)</p>"},{"location":"PR%C3%81CTICA%208/#4-resultados","title":"4) Resultados","text":"<p>_Al subir el programa al ESP32 y conectarlo a la red WiFi, el monitor serial muestra la direcci\u00f3n IP local asignada. Esta direcci\u00f3n es introducida en un navegador dentro de la misma red para abrir la interfaz web.</p> <p>La p\u00e1gina principal permite controlar un LED mediante un bot\u00f3n que cambia din\u00e1micamente su estado de \u201cON\u201d a \u201cOFF\u201d. Para los otros dos LEDs, se accede a trav\u00e9s de rutas espec\u00edficas (/on1, /off1, /on2, /off2) en la URL, lo cual permite verificar el funcionamiento del servidor al interpretar diferentes solicitudes HTTP.</p> <p>El bot\u00f3n HTML permite encender o apagar un LED (pin LED_BUILTIN) de forma remota, con cambios din\u00e1micos en el texto del bot\u00f3n y estado del LED.</p> <p>Los sliders permiten modificar valores de 0 a 180, los cuales son mapeados a un rango de se\u00f1al PWM (205 a 410). Esto se refleja en la intensidad de salida en los pines definidos por #define pwm 3 y #define pwm1 2, ideal para el control de brillo de LEDs o velocidad de servomotores.</p> <p>Al escribir en la caja de texto y presionar \u201cEnviar\u201d, el valor se muestra en el monitor serial como confirmaci\u00f3n de recepci\u00f3n.</p> <p>Todas las acciones generan peticiones HTTP (GET) que el servidor del ESP32 interpreta correctamente, generando una respuesta inmediata y modificando salidas f\u00edsicas.</p>"},{"location":"PR%C3%81CTICA%208/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n#define pwm 3\n#define pwm1 2\n\nconst char* ssid = \"iPhone\";\nconst char* password = \"karennajera\";\n\nWebServer servidor(80);\n\nconst int ledPin = LED_BUILTIN;\nString ledState = \"OFF\";\nint sliderValue = 0;\nint sliderValue1 = 0;\n\nconst char htmlTemplate[] PROGMEM = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de LED ESP32&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Control de LED ESP32&lt;/h1&gt;\n    &lt;p&gt;El LED est\u00e1 %LED_STATE%&lt;/p&gt;\n    &lt;a href=\"/%LINK%\"&gt;&lt;button&gt;%BUTTON_TEXT%&lt;/button&gt;&lt;/a&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Control del Slider&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE%\" id=\"slider\" oninput=\"updateSlider(this.value)\"&gt;\n    &lt;span id=\"sliderValue\"&gt;%SLIDER_VALUE%&lt;/span&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Segundo Slider&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE1%\" id=\"slider1\" oninput=\"updateSlider1(this.value)\"&gt;\n    &lt;span id=\"sliderValue1\"&gt;%SLIDER_VALUE1%&lt;/span&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Ingresar Texto&lt;/h2&gt;\n    &lt;input type=\"text\" id=\"txtInput\" placeholder=\"Escribe algo...\"&gt;\n    &lt;button onclick=\"sendText()\"&gt;Enviar&lt;/button&gt;\n\n    &lt;script&gt;\n      function updateSlider(value) {\n        document.getElementById('sliderValue').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      function updateSlider1(value) {\n        document.getElementById('sliderValue1').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider1?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      function sendText() {\n        var textValue = document.getElementById('txtInput').value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/textbox?value=\" + encodeURIComponent(textValue), true);\n        xhr.send();\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n)rawliteral;\n\nvoid handleroot() {\n  String html = String(htmlTemplate);\n  html.replace(\"%LED_STATE%\", ledState);\n  html.replace(\"%SLIDER_VALUE%\", String(sliderValue));\n  html.replace(\"%SLIDER_VALUE1%\", String(sliderValue1));\n  if (ledState == \"OFF\") {\n    html.replace(\"%LINK%\", \"ON\");\n    html.replace(\"%BUTTON_TEXT%\", \"Encender\");\n  } else {\n    html.replace(\"%LINK%\", \"OFF\");\n    html.replace(\"%BUTTON_TEXT%\", \"Apagar\");\n  }\n  servidor.send(200, \"text/html\", html);\n}\n\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleroot();\n}\n\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleroot();\n}\n\nvoid handleSlider() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue));\n    int duty = map(sliderValue, 0, 180, 205, 410);\n    ledcWrite(pwm, duty);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleSlider1() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue1 = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del segundo slider: \" + String(sliderValue1));\n    int duty1 = map(sliderValue1, 0, 180, 205, 410);\n    ledcWrite(pwm1, duty1);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleTextbox() {\n  if (servidor.hasArg(\"value\")) {\n    String textValue = servidor.arg(\"value\");\n    Serial.println(\"Texto recibido: \" + textValue);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  ledcAttachChannel(pwm, 50, 12, 0);\n  ledcAttachChannel(pwm1, 50, 12, 1);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\\nWiFi conectado\");\n  Serial.println(WiFi.localIP());\n\n  servidor.on(\"/\", handleroot);\n  servidor.on(\"/ON\", handleOn);\n  servidor.on(\"/OFF\", handleOff);\n  servidor.on(\"/slider\", handleSlider);\n  servidor.on(\"/slider1\", handleSlider1);\n  servidor.on(\"/textbox\", handle\n</code></pre>"},{"location":"PR%C3%81CTICA%208/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 comprobar que el ESP32 puede actuar como un servidor web funcional que permite controlar perif\u00e9ricos en tiempo real desde una interfaz gr\u00e1fica. El sistema implementado constituye una base s\u00f3lida para aplicaciones m\u00e1s complejas del Internet de las Cosas (IoT), como dom\u00f3tica, monitoreo remoto o automatizaci\u00f3n industrial.</p> <p>La integraci\u00f3n entre HTML, JavaScript y el servidor embebido del ESP32 permite la creaci\u00f3n de interfaces intuitivas que facilitan la interacci\u00f3n hombre-m\u00e1quina sin necesidad de aplicaciones externas. Adem\u00e1s, el manejo de se\u00f1ales PWM desde el navegador extiende la utilidad del sistema para control preciso de actuadores. Se concluye que el ESP32 es una herramienta poderosa, flexible y accesible para el desarrollo de sistemas embebidos conectados a red..</p>"},{"location":"PR%C3%81CTICA%209/","title":"Pr\u00e1ctica 9 (P9): Comunicaci\u00f3n ESP-NOW con 3 botones y 3 LEDs","text":""},{"location":"PR%C3%81CTICA%209/#1-resumen","title":"1) Resumen","text":"<ul> <li>Rol del nodo: ESP32-C6 en WIFI_STA usando ESP-NOW. Lee 3 botones (GPIO 2, 3, 4) y env\u00eda su estado a tres peers (por MAC). Adem\u00e1s recibe paquetes y conmuta 3 LEDs (GPIO 10, 11, 12) seg\u00fan el origen y el payload.</li> </ul>"},{"location":"PR%C3%81CTICA%209/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar ESP-NOW y registrar tres peers por direcci\u00f3n MAC.</li> <li>Enviar el estado de cada bot\u00f3n al peer correspondiente.</li> <li>Recibir datos y accionar LEDs en funci\u00f3n de la MAC fuente y del campo b del payload.</li> <li>Verificar el funcionamiento mediante logs en el Monitor Serie.</li> </ul>"},{"location":"PR%C3%81CTICA%209/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>3 pulsadores (conexi\u00f3n pull-down o pull-up)  </li> <li>3 LEDs con resistencias (GPIO 10, 11, 12)  </li> <li>Protoboard y jumpers  </li> <li>Arduino IDE (core ESP32)</li> </ul> <p>Nota el\u00e9ctrica: Comparte GND entre todos los elementos y usa resistencias para LEDs. Define consistentemente pull-up/pull-down.</p>"},{"location":"PR%C3%81CTICA%209/#4-codigo-p9","title":"4) C\u00f3digo (P9)","text":"<pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\nuint8_t broadcastAddress[] = {0x7C, 0x2C, 0x67, 0x55, 0xD6, 0x88}; //mAC ADREES DEL OTRO ESP32\nuint8_t broadcastAddress2[] = {0x7C, 0x2C, 0x67, 0x55, 0xD8, 0xDC};\nuint8_t broadcastAddress3[] = {0x7C, 0x2C, 0x67, 0x55, 0xD4, 0xE0};\n\nint led1 = 10;\nint led2 = 11;\nint led3 = 12;\nint boton1 = 2;\nint boton2 = 3;\nint boton3 = 4;\n\n//Enviar\n// Estructura de datos (m\u00e1x. 250 bytes)\n\ntypedef struct struct_msj {\n  char a[32];\n  int b;\n  float c;\n  bool d;\n} struct_msj;\nstruct_msj datosEnviados;\nstruct_msj datosRecibidos;\nstruct_msj datosEnviados2;\nstruct_msj datosRecibidos2;\nstruct_msj datosEnviados3;\nstruct_msj datosRecibidos3;\n\nesp_now_peer_info_t peerInfo;\nesp_now_peer_info_t peerInfo2;\nesp_now_peer_info_t peerInfo3;\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos));\n  // Imprimir informaci\u00f3n de la fuente (opcional)\n  char macStr[18];\n  snprintf(macStr, sizeof(macStr),\n           \"%02X:%02X:%02X:%02X:%02X:%02X\",\n           info-&gt;src_addr[0], info-&gt;src_addr[1], info-&gt;src_addr[2],\n           info-&gt;src_addr[3], info-&gt;src_addr[4], info-&gt;src_addr[5]);\n  Serial.printf(\"Datos recibidos de: %s\\n\", macStr);\n  //Serial.printf(\"Bytes recibidos: %d\\n\", tam);\n  if(info-&gt;src_addr[5] == 0x88)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led1, HIGH);\n    }\n    else {\n      digitalWrite(led1, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xE0)\n  {\n    if (datosRecibidos.b==1) {\n      digitalWrite(led2, HIGH);\n    }\n    else {\n      digitalWrite(led2, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xDC)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led3, HIGH);\n    }\n    else {\n      digitalWrite(led3, LOW);\n    }\n  }\n\n  Serial.printf(\"Int: %d\\n\", datosRecibidos.b);\n  //Serial.printf(\"Float: %.2f\\n\", datosRecibidos.c);\n  //Serial.printf(\"Bool: %d\\n\\n\", datosRecibidos.d);\n}\nvoid setup()\n{\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  pinMode(boton1, INPUT);\n  pinMode(boton2, INPUT);\n  pinMode(boton3, INPUT);\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n  if (esp_now_init() != ESP_OK)\n  {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n  memset(&amp;peerInfo, 0, sizeof(peerInfo));\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  // Configurar peer\n  memset(&amp;peerInfo2, 0, sizeof(peerInfo2));\n  memcpy(peerInfo2.peer_addr, broadcastAddress2, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo2) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n    memset(&amp;peerInfo3, 0, sizeof(peerInfo3));\n  memcpy(peerInfo3.peer_addr, broadcastAddress3, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo3) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  Serial.println(\"ESP-NOW listo para enviar\");\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop()\n{\n  //aqui imprime estado botones\n  Serial.print(\"Bot\u00f3n 1: \");\n  Serial.print(digitalRead(boton1));\n  Serial.print(\" | Bot\u00f3n 2: \");\n  Serial.print(digitalRead(boton2));\n  Serial.print(\" | Bot\u00f3n 3: \");\n  Serial.println(digitalRead(boton3));\n\n  strcpy(datosEnviados.a, \"Hola Mundo\");\n  datosEnviados.c = 3.14;\n  datosEnviados.d = true;\n\n\n  if(digitalRead(boton1) == HIGH){\n    datosEnviados.b = 1;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                    (uint8_t *)&amp;datosEnviados,\n                                    sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton1) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  if(digitalRead(boton2) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));  \n  }\n  else if(digitalRead(boton2) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  if(digitalRead(boton3) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton3) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  delay(2000);\n}\n</code></pre>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"recursos/PR%C3%81CTICA%203/","title":"\ud83d\udcda Pr\u00e1ctica 1: Comunicaci\u00f3n Serial con ESP32-C6 en Arduino","text":""},{"location":"recursos/PR%C3%81CTICA%203/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un c\u00f3digo en Arduino IDE para establecer comunicaci\u00f3n serial con un ESP32-C6. Se explic\u00f3 el funcionamiento de los diferentes tipos de variables (<code>int</code>, <code>char</code>, <code>string</code>, <code>float</code>, <code>bool</code>) y la cantidad de datos que puede almacenar cada uno. Adem\u00e1s, se analizaron las diferencias entre los dos puertos de comunicaci\u00f3n del ESP32 (UART y USB nativo) y c\u00f3mo este recibe mensajes enviados desde el monitor serial.</li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender el funcionamiento b\u00e1sico de la comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Identificar y diferenciar los principales tipos de variables en Arduino.  </li> <li>Implementar un programa que permita recibir y mostrar mensajes en el monitor serial.  </li> <li>Analizar la diferencia entre el puerto UART (serial cl\u00e1sico) y el puerto USB nativo del ESP32.  </li> <li>Verificar la correcta recepci\u00f3n y env\u00edo de caracteres mediante pruebas pr\u00e1cticas.  </li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Uso del ESP32-C6 como dispositivo de comunicaci\u00f3n serial.  </li> <li>Configuraci\u00f3n del baud rate en el monitor serial.  </li> <li>Recepci\u00f3n y env\u00edo de mensajes en el IDE de Arduino.  </li> <li> <p>Explicaci\u00f3n te\u00f3rica de los tipos de variables y su uso en la pr\u00e1ctica.  </p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Programaci\u00f3n de librer\u00edas adicionales.  </li> <li>Uso de comunicaci\u00f3n inal\u00e1mbrica (Wi-Fi / Bluetooth).  </li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#4-resultados","title":"4) Resultados","text":"<p>Durante la pr\u00e1ctica se logr\u00f3:  </p> <ul> <li>Recepci\u00f3n de datos seriales: El ESP32-C6 recibi\u00f3 correctamente mensajes enviados desde el monitor serial, aunque en un inicio aparecieron caracteres extra\u00f1os debido a un baud rate incorrecto. Ajustando la velocidad a 38400 baudios se solucion\u00f3 el problema.  </li> <li>Tipos de datos: </li> <li><code>int</code> \u2192 n\u00fameros enteros (16 bits).  </li> <li><code>char</code> \u2192 un car\u00e1cter (1 byte).  </li> <li><code>string</code> \u2192 cadena de caracteres (m\u00ednimo 16 bits, m\u00e1ximo variable).  </li> <li><code>float</code> \u2192 n\u00fameros con decimales (32 bits).  </li> <li><code>bool</code> \u2192 valores l\u00f3gicos (1 bit).  </li> <li>Puertos de comunicaci\u00f3n: </li> <li>UART (Universal Asynchronous Receiver-Transmitter): puerto serial tradicional, \u00fatil para depuraci\u00f3n o conexi\u00f3n con otros dispositivos.  </li> <li>USB nativo: permite programar directamente el microcontrolador y tambi\u00e9n enviar datos sin necesidad de un conversor externo.  </li> </ul> <p>C\u00f3digo Implementado</p> <p>```cpp char msg;</p> <p>void setup() {   Serial.begin(38400);   // Inicializa comunicaci\u00f3n serial }</p> <p>void loop() {   if (Serial.available()) {   // Verifica si hay datos     msg = Serial.read();      // Lee el car\u00e1cter     Serial.print(msg);        // Lo reenv\u00eda al monitor   } }</p>"}]}